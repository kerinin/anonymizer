(function() {
  var EventEmitter, async, fs, helpers, mkdirp, path, requireDefinition, util, wrap,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  mkdirp = require('mkdirp');

  path = require('path');

  util = require('util');

  helpers = require('./helpers');

  exports.copyFile = function(source, destination, callback) {
    var read, write;
    read = fs.createReadStream(source);
    write = fs.createWriteStream(destination);
    return util.pump(read, write, function() {
      return typeof callback === "function" ? callback() : void 0;
    });
  };

  exports.walkTreeAndCopyFiles = function(source, destination, callback) {
    return fs.readdir(source, function(error, files) {
      if (error) return callback(error);
      return async.forEach(files, function(file, next) {
        var destPath, sourcePath;
        if (file.match(/^\./)) return next();
        sourcePath = path.join(source, file);
        destPath = path.join(destination, file);
        return fs.stat(sourcePath, function(error, stats) {
          if (!error && stats.isDirectory()) {
            return fs.mkdir(destPath, 0755, function() {
              return exports.walkTreeAndCopyFiles(sourcePath, destPath, function(error, destPath) {
                if (destPath) {
                  return callback(error, destPath);
                } else {
                  return next();
                }
              });
            });
          } else {
            return exports.copyFile(sourcePath, destPath, function() {
              callback(error, destPath);
              return next();
            });
          }
        });
      }, callback);
    });
  };

  exports.recursiveCopy = function(source, destination, callback) {
    return mkdirp(destination, 0755, function(error) {
      var paths;
      paths = [];
      return exports.walkTreeAndCopyFiles(source, destination, function(err, filename) {
        if (err) {
          return callback(err);
        } else if (filename) {
          return paths.push(filename);
        } else {
          return callback(err, paths.sort());
        }
      });
    });
  };

  exports.FSWatcher = (function(_super) {

    __extends(FSWatcher, _super);

    FSWatcher.prototype.invalid = /^(\.|#)/;

    function FSWatcher(files) {
      var file, _i, _len;
      this.watched = {};
      if (Array.isArray(files)) {
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          this._handle(file);
        }
      } else {
        this._handle(files);
      }
    }

    FSWatcher.prototype._getWatchedDir = function(directory) {
      var _base, _ref;
      return (_ref = (_base = this.watched)[directory]) != null ? _ref : _base[directory] = [];
    };

    FSWatcher.prototype._watch = function(item, callback) {
      var basename, parent,
        _this = this;
      parent = this._getWatchedDir(path.dirname(item));
      basename = path.basename(item);
      if (__indexOf.call(parent, basename) >= 0) return;
      parent.push(basename);
      return fs.watchFile(item, {
        persistent: true,
        interval: 100
      }, function(curr, prev) {
        if (curr.mtime.getTime() !== prev.mtime.getTime()) {
          return typeof callback === "function" ? callback(item) : void 0;
        }
      });
    };

    FSWatcher.prototype._handleFile = function(file) {
      var emit,
        _this = this;
      emit = function(file) {
        return _this.emit('change', file);
      };
      emit(file);
      return this._watch(file, emit);
    };

    FSWatcher.prototype._handleDir = function(directory) {
      var read,
        _this = this;
      read = function(directory) {
        return fs.readdir(directory, function(error, current) {
          var file, previous, _i, _j, _len, _len2, _results;
          if (error != null) return helpers.logError(error);
          if (!current) return;
          previous = _this._getWatchedDir(directory);
          for (_i = 0, _len = previous.length; _i < _len; _i++) {
            file = previous[_i];
            if (__indexOf.call(current, file) < 0) _this.emit('remove', file);
          }
          _results = [];
          for (_j = 0, _len2 = current.length; _j < _len2; _j++) {
            file = current[_j];
            if (__indexOf.call(previous, file) < 0) {
              _results.push(_this._handle(path.join(directory, file)));
            }
          }
          return _results;
        });
      };
      read(directory);
      return this._watch(directory, read);
    };

    FSWatcher.prototype._handle = function(file) {
      var _this = this;
      if (this.invalid.test(path.basename(file))) return;
      return fs.realpath(file, function(error, filePath) {
        if (error != null) return helpers.logError(error);
        return fs.stat(file, function(error, stats) {
          if (error != null) return helpers.logError(error);
          if (stats.isFile()) _this._handleFile(file);
          if (stats.isDirectory()) return _this._handleDir(file);
        });
      });
    };

    FSWatcher.prototype.on = function() {
      FSWatcher.__super__.on.apply(this, arguments);
      return this;
    };

    FSWatcher.prototype.close = function() {
      var directory, file, files, _i, _len, _ref;
      _ref = this.watched;
      for (directory in _ref) {
        files = _ref[directory];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          fs.unwatchFile(path.join(directory, file));
        }
      }
      this.watched = {};
      return this;
    };

    return FSWatcher;

  })(EventEmitter);

  requireDefinition = '(function(/*! Brunch !*/) {\n  if (!this.require) {\n    var modules = {}, cache = {}, require = function(name, root) {\n      var module = cache[name], path = expand(root, name), fn;\n      if (module) {\n        return module;\n      } else if (fn = modules[path] || modules[path = expand(path, \'./index\')]) {\n        module = {id: name, exports: {}};\n        try {\n          cache[name] = module.exports;\n          fn(module.exports, function(name) {\n            return require(name, dirname(path));\n          }, module);\n          return cache[name] = module.exports;\n        } catch (err) {\n          delete cache[name];\n          throw err;\n        }\n      } else {\n        throw \'module \\\'\' + name + \'\\\' not found\';\n      }\n    }, expand = function(root, name) {\n      var results = [], parts, part;\n      if (/^\\.\\.?(\\/|$)/.test(name)) {\n        parts = [root, name].join(\'/\').split(\'/\');\n      } else {\n        parts = name.split(\'/\');\n      }\n      for (var i = 0, length = parts.length; i < length; i++) {\n        part = parts[i];\n        if (part == \'..\') {\n          results.pop();\n        } else if (part != \'.\' && part != \'\') {\n          results.push(part);\n        }\n      }\n      return results.join(\'/\');\n    }, dirname = function(path) {\n      return path.split(\'/\').slice(0, -1).join(\'/\');\n    };\n    this.require = function(name) {\n      return require(name, \'\');\n    }\n    this.require.define = function(bundle) {\n      for (var key in bundle)\n        modules[key] = bundle[key];\n    };\n  }\n}).call(this);';

  exports.wrap = wrap = function(filePath, data) {
    var moduleName;
    moduleName = JSON.stringify(filePath.replace(/^app\//, '').replace(/\.\w*$/, ''));
    return "(this.require.define({\n  " + moduleName + ": function(exports, require, module) {\n    " + data + "\n  }\n}));\n";
  };

  exports.FileWriter = (function(_super) {

    __extends(FileWriter, _super);

    FileWriter.prototype.timeout = 50;

    function FileWriter(buildPath, files) {
      this.buildPath = buildPath;
      this.files = files;
      this._write = __bind(this._write, this);
      this._writeFile = __bind(this._writeFile, this);
      this._onRemove = __bind(this._onRemove, this);
      this._onChange = __bind(this._onChange, this);
      this.destFiles = [];
      this.on('change', this._onChange);
      this.on('remove', this._onRemove);
    }

    FileWriter.prototype._getDestFile = function(destinationPath) {
      var destFile;
      destFile = this.destFiles.filter(function(file) {
        return file.path === destinationPath;
      })[0];
      if (!destFile) {
        destFile = {
          path: destinationPath,
          sourceFiles: []
        };
        this.destFiles.push(destFile);
      }
      return destFile;
    };

    FileWriter.prototype._onChange = function(changedFile) {
      var destFile, sourceFile;
      destFile = this._getDestFile(changedFile.destinationPath);
      sourceFile = destFile.sourceFiles.filter(function(file) {
        return file.path === changedFile.path;
      })[0];
      if (!sourceFile) {
        sourceFile = changedFile;
        destFile.sourceFiles.push(sourceFile);
        delete sourceFile.destinationPath;
      }
      sourceFile.data = changedFile.data;
      if (this.timeoutId != null) clearTimeout(this.timeoutId);
      return this.timeoutId = setTimeout(this._write, this.timeout);
    };

    FileWriter.prototype._onRemove = function(removedFile) {
      var destFile;
      destFile = this._getDestFile(removedFile.destinationPath);
      return destFile.sourceFiles = destFile.sourceFiles.filter(function(sourceFile) {
        return sourceFile.path !== removedFile.path;
      });
    };

    FileWriter.prototype._getFilesData = function(destFile) {
      var data, destIsJS;
      destIsJS = /\.js$/.test(destFile.path);
      data = '';
      if (destIsJS) data += requireDefinition;
      data += destFile.sourceFiles.map(function(sourceFile) {
        if (destIsJS && !(/^vendor/.test(sourceFile.path))) {
          return wrap(sourceFile.path, sourceFile.data);
        } else {
          return sourceFile.data;
        }
      }).join('');
      return data;
    };

    FileWriter.prototype._writeFile = function(destFile, callback) {
      var data, destPath, files, order, pathes, writeFile,
        _this = this;
      files = destFile.sourceFiles;
      pathes = files.map(function(file) {
        return file.path;
      });
      order = this.files[destFile.path].order;
      destFile.sourceFiles = (helpers.sort(pathes, order)).map(function(file) {
        return files[pathes.indexOf(file)];
      });
      destPath = path.join(this.buildPath, destFile.path);
      data = this._getFilesData(destFile);
      writeFile = function(callback) {
        return fs.writeFile(destPath, data, callback);
      };
      return writeFile(function(error) {
        if (error != null) {
          return mkdirp(path.dirname(destPath), 0755, function(error) {
            if (error != null) callback(error);
            return writeFile(function(error) {
              return callback(error, {
                path: destPath,
                data: data
              });
            });
          });
        } else {
          return callback(null, {
            path: destPath,
            data: data
          });
        }
      });
    };

    FileWriter.prototype._write = function() {
      var _this = this;
      return async.forEach(this.destFiles, this._writeFile, function(error, results) {
        if (error != null) return _this.emit('error');
        return _this.emit('write', results);
      });
    };

    return FileWriter;

  })(EventEmitter);

}).call(this);
