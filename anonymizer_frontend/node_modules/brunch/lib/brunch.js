(function() {
  var async, exec, fs, fs_utils, getLanguagesFromConfig, helpers, mkdirp, path, watchApplication;

  async = require('async');

  exec = require('child_process').exec;

  fs = require('fs');

  mkdirp = require('mkdirp');

  path = require('path');

  fs_utils = require('./fs_utils');

  helpers = require('./helpers');

  getLanguagesFromConfig = function(config) {
    var destinationPath, language, languages, regExp, settings, _ref, _ref2;
    languages = [];
    _ref = config.files;
    for (destinationPath in _ref) {
      settings = _ref[destinationPath];
      _ref2 = settings.languages;
      for (regExp in _ref2) {
        language = _ref2[regExp];
        try {
          languages.push({
            regExp: RegExp("" + regExp),
            destinationPath: destinationPath,
            compiler: new language(config)
          });
        } catch (error) {
          helpers.logError("[Brunch]: cannot parse config entry \nconfig.files['" + destinationPath + "'].languages['" + regExp + "']: " + error + ".");
        }
      }
    }
    return languages;
  };

  watchApplication = function(rootPath, buildPath, config, persistent, callback) {
    var directories, languages, plugins, watcher, writer, _ref;
    if (typeof buildPath === 'object') {
      _ref = [buildPath, config, persistent], config = _ref[0], persistent = _ref[1], callback = _ref[2];
      buildPath = null;
    }
    if (buildPath == null) buildPath = path.join(rootPath, 'build');
    config.rootPath = rootPath;
    config.buildPath = buildPath;
    if (config.port) helpers.startServer(config.port, config.buildPath);
    plugins = config.plugins.map(function(plugin) {
      return new plugin(config);
    });
    languages = getLanguagesFromConfig(config);
    directories = ['app', 'vendor'].map(function(dir) {
      return path.join(rootPath, dir);
    });
    writer = new fs_utils.FileWriter(buildPath, config.files);
    watcher = (new fs_utils.FSWatcher(directories)).on('change', function(file) {
      return languages.filter(function(language) {
        return language.regExp.test(file);
      }).forEach(function(language) {
        var compiler, destinationPath;
        compiler = language.compiler, destinationPath = language.destinationPath;
        return compiler.compile(file, function(error, data) {
          var languageName;
          if (error != null) {
            languageName = compiler.constructor.name.replace('Language', '');
            return helpers.logError("[" + languageName + "]: cannot compile '" + file + "': " + error);
          }
          return writer.emit('change', {
            destinationPath: destinationPath,
            path: file,
            data: data
          });
        });
      });
    }).on('remove', function(file) {
      return writer.emit('remove', file);
    });
    writer.on('error', function(error) {
      return helpers.logError("[Brunch] write error. " + error);
    });
    writer.on('write', function(result) {
      return async.forEach(plugins, function(plugin, next) {
        return plugin.load(next);
      }, function(error) {
        if (error != null) {
          return helpers.logError("[Brunch]: plugin error. " + error);
        }
        helpers.log("[Brunch]: compiled.");
        if (!persistent) watcher.close();
        return callback(result);
      });
    });
    return watcher;
  };

  exports["new"] = function(rootPath, buildPath, callback) {
    var templatePath;
    if (callback == null) callback = (function() {});
    if (typeof buildPath === 'function') callback = buildPath;
    if (buildPath == null) buildPath = path.join(rootPath, 'build');
    templatePath = path.join(__dirname, '..', 'template', 'base');
    return path.exists(rootPath, function(exists) {
      if (exists) {
        return helpers.logError("[Brunch]: can\'t create project: directory \"" + rootPath + "\" already exists");
      }
      return mkdirp(rootPath, 0755, function(error) {
        if (error != null) return helpers.logError("[Brunch]: Error " + error);
        return mkdirp(buildPath, 0755, function(error) {
          if (error != null) return helpers.logError("[Brunch]: Error " + error);
          return fs_utils.recursiveCopy(templatePath, rootPath, function() {
            var prevDir;
            helpers.log('[Brunch]: created brunch directory layout');
            helpers.log('[Brunch]: installing npm packages...');
            prevDir = process.cwd();
            process.chdir(rootPath);
            return exec('npm install', function(error) {
              process.chdir(prevDir);
              if (error != null) {
                helpers.logError("[Brunch]: npm error: " + error);
                return callback(error);
              }
              helpers.log('[Brunch]: installed npm package brunch-extensions');
              return callback();
            });
          });
        });
      });
    });
  };

  exports.build = function(rootPath, buildPath, config, callback) {
    if (callback == null) callback = (function() {});
    return watchApplication(rootPath, buildPath, config, false, callback);
  };

  exports.watch = function(rootPath, buildPath, config, callback) {
    if (callback == null) callback = (function() {});
    return watchApplication(rootPath, buildPath, config, true, callback);
  };

  exports.generate = function(rootPath, type, name, callback) {
    var className, data, extension, filePath, filename, genName, generateFile, generateTests;
    if (callback == null) callback = (function() {});
    extension = (function() {
      switch (type) {
        case 'style':
          return 'styl';
        default:
          return 'coffee';
      }
    })();
    filename = "" + name + "." + extension;
    filePath = path.join(rootPath, 'app', "" + type + "s", filename);
    data = (function() {
      switch (extension) {
        case 'coffee':
          genName = helpers.capitalize(type);
          className = helpers.formatClassName(name);
          return "class exports." + className + " extends Backbone." + genName + "\n";
        default:
          return '';
      }
    })();
    generateFile = function(callback) {
      return fs.writeFile(filePath, data, function(error) {
        if (error != null) return helpers.logError(error);
        helpers.log("Generated " + filePath);
        return callback();
      });
    };
    generateTests = function(callback) {
      var testDirPath, testFilePath, write;
      if (extension !== 'coffee') return callback();
      testDirPath = path.join(rootPath, 'test', 'unit', "" + type + "s");
      testFilePath = path.join(testDirPath, "" + name + "_test." + extension);
      write = function() {
        return fs.writeFile(testFilePath, '', function(error) {
          if (error != null) return helpers.logError(error);
          helpers.log("Generated " + testFilePath);
          return callback();
        });
      };
      return path.exists(testDirPath, function(exists) {
        if (exists) return write();
        return mkdirp(testDirPath, 0755, function(error) {
          if (error != null) return helpers.logError(error);
          return write();
        });
      });
    };
    return generateFile(function() {
      return generateTests(function() {
        return callback();
      });
    });
  };

}).call(this);
